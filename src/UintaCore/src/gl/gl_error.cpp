#include <uinta/gl/gl_error.h>
#include <uinta/gl/gl_types.h>

#include <iostream> // TODO remove when logging is implemented

namespace uinta {

	void checkGlBufferData(GLenum err) {
		switch (err) {
			case GL_INVALID_ENUM:
				std::cerr << "glBufferData GL_INVALID_ENUM: Either;";
				std::cerr << "\n\t1)_target is not one of the accepted buffer targets. Or,";
				std::cerr << "\n\t2) _usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, ";
				std::cerr << "GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, ";
				std::cerr << "GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.";
				std::cerr << std::endl;
				return;

			case GL_INVALID_VALUE:
				std::cerr << "glBufferData GL_INVALID_VALUE: Size is negative." << std::endl;
				return;

			case GL_INVALID_OPERATION:
				std::cerr << "glBufferData GL_INVALID_OPERATION: The reserved buffer object named 0 is ";
				std::cerr << "bound to target." << std::endl;
				return;

			case GL_OUT_OF_MEMORY:
				std::cerr << "glBufferData GL_INVALID_OPERATION: GL is unable to create a data store ";
				std::cerr << "with the specified size." << std::endl;
				return;

			default:
				std::cerr << "Unknown glBufferData error." << std::endl;
		}
	}

	void checkGlGenBuffers(GLenum err) {
		if (err == GL_INVALID_VALUE) {
			std::cerr << "glGenBuffers GL_INVALID_VALUE: n is negative." << std::endl;
		} else {
			std::cerr << "Unknown glGenBuffers error." << std::endl;
		}
	}

	void checkGlVertexAttribPointer(GLenum err) {
		switch (err) {
			case GL_INVALID_VALUE:
				std::cerr << "glVertexAttribPointer GL_INVALID_VALUE: Either;";
				std::cerr << "\n\t1) _index is greater than or equal to GL_MAX_VERTEX_ATTRIBS. Or,";
				std::cerr << "\n\t2) _size is not 1, 2, 3 or 4.";
				std::cerr << "\n\t3) _stride is negative." << std::endl;
				break;

			case GL_INVALID_ENUM:
				std::cerr << "glVertexAttribPointer GL_INVALID_ENUM: _type is not an accepted value." << std::endl;
				break;

			case GL_INVALID_OPERATION:
				std::cerr << "glVertexAttribPointer GL_INVALID_OPERATION: Either;";
				std::cerr << "\n\t1) _type is GL_INT_2_10_10_10_REV or ";
				std::cerr << "GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4. Or,";
				std::cerr << "\n\t2) A non-zero vertex array object is bound, zero is bound to the ";
				std::cerr << "GL_ARRAY_BUFFER buffer object binding point and the pointer argument ";
				std::cerr << "is not NULL." << std::endl;
				break;

			default:
				std::cerr << "Unknown glVertexAttribPointer error." << std::endl;
		}
	}

	void checkGlBufferSubData(GLenum err) {
		switch (err) {
			case GL_INVALID_ENUM:
				std::cerr << "glBufferSubData GL_INVALID_ENUM: Unacceptable VBO target type." << std::endl;
				return;

			case GL_INVALID_VALUE:
				std::cerr << "glBufferSubData GL_INVALID_VALUE: VBO offset or size is negative, or together ";
				std::cerr << "they define a region of memory that extends beyond the buffer object's allocated ";
				std::cerr << "data store." << std::endl;
				return;

			case GL_INVALID_OPERATION:
				std::cerr << "glBufferSubData GL_INVALID_OPERATION: VBO operation invalid because either;";
				std::cerr << "\n\t1) The reserved buffer object name O is bound to target. Or,";
				std::cerr << "\n\t2) The buffer object being updated is mapped." << std::endl;
				return;


			default:
				std::cerr << "Unknown glBufferSubData error." << std::endl;
		}
	}

	void checkGlBindBuffer(GLenum err) {
		if (err == GL_INVALID_ENUM) {
			std::cerr << "glBindBuffer GL_INVALID_ENUM: _target is not one of the allowable values." << std::endl;
		} else {
			std::cerr << "Unknown glBindBuffer error." << std::endl;
		}
	}

	void checkGlDisableVertexAttribArray(GLenum err) {
		if (err == GL_INVALID_VALUE) {
			std::cerr << "glDisableVertexAttribArray  GL_INVALID_VALUE: _index is greater than or equal to ";
			std::cerr << "GL_MAX_VERTEX_ATTRIBS" << std::endl;
		} else {
			std::cerr << "Unknown glDisableVertexAttribArray error." << std::endl;
		}
	}

	void checkGlEnableVertexAttribArray(GLenum err) {
		if (err == GL_INVALID_VALUE) {
			std::cerr << "glEnableVertexAttribArray  GL_INVALID_VALUE: _index is greater than or equal to ";
			std::cerr << "GL_MAX_VERTEX_ATTRIBS" << std::endl;
		} else {
			std::cerr << "Unknown glEnableVertexAttribArray error." << std::endl;
		}
	}

}

void checkGlCreateShader(GLenum err) {
	if (err == GL_INVALID_ENUM) {
		std::cerr << "_shaderType is not an accepted value." << std::endl;
	} else {
		std::cerr << "Unknown glCreateShader error." << std::endl;
	}
}

void checkGlShaderSource(GLenum err) {
	switch (err) {
		case GL_INVALID_VALUE:
			std::cerr << "glShaderSource GL_INVALID_VALUE: Either;";
			std::cerr << "\n\t1) _shader is not a value generated by OpenGL. Or,";
			std::cerr << "\n\t2) _count is less than 0." << std::endl;
			break;
		case GL_INVALID_OPERATION:
			std::cerr << "glShaderSource GL_INVALID_OPERATION: _shader is not a shader object." << std::endl;
			break;

		default:
			std::cerr << "Unknown glShaderSource error." << std::endl;
			break;
	}
}

void checkGlCompileShader(GLenum err) {
	switch (err) {
		case GL_INVALID_VALUE:
			std::cerr << "glShaderSource GL_INVALID_VALUE: _shader is not a value generated by OpenGL." << std::endl;
			break;
		case GL_INVALID_OPERATION:
			std::cerr << "glShaderSource GL_INVALID_OPERATION: _shader is not a shader object." << std::endl;
			break;

		default:
			std::cerr << "Unknown glCompileShader error." << std::endl;
			break;
	}
}

#pragma clang diagnostic push
#pragma ide diagnostic ignored "UnusedLocalVariable" // disables `err` unused warning

void checkGlCreateProgram(GLenum err) {
	// Intentionally empty. This method does not throw any errors as of OpenGL 4.5.
}

#pragma clang diagnostic pop

void checkGlAttachShader(GLenum err) {
	switch (err) {
		case GL_INVALID_VALUE:
			std::cerr << "glAttachShader GL_INVALID_VALUE: Either _program or ";
			std::cerr << "_shader is not a value generated by OpenGL." << std::endl;
			break;
		case GL_INVALID_OPERATION:
			std::cerr << "glAttachShader GL_INVALID_OPERATION: Either;";
			std::cerr << "\n\t1) _program is not a program object. Or,";
			std::cerr << "\n\t2) _shader is not a shader object. Or,";
			std::cerr << "\n\t3) _shader is already attached to program.";
			std::cerr << "\n\t4) A shader of the same type as _shader is already attached to program." << std::endl;
			break;

		default:
			std::cerr << "Unknown glAttachShader error." << std::endl;
			break;
	}
}

void checkGlLinkProgram(GLenum err) {
	switch (err) {
		case GL_INVALID_VALUE:
			std::cerr << "glLinkProgram GL_INVALID_VALUE: _program is not a value generated by OpenGL." << std::endl;
			break;
		case GL_INVALID_OPERATION:
			std::cerr << "glLinkProgram GL_INVALID_OPERATION: Either;";
			std::cerr << "\n\t1) _program is not a program object.";
			std::cerr << "\n\t2) _program is the currently active program object and transform ";
			std::cerr << "feedback mode is active." << std::endl;
			break;

		default:
			std::cerr << "Unknown glLinkProgram error." << std::endl;
			break;
	}
}

void checkGlDeleteShader(GLenum err) {
	if (err == GL_INVALID_VALUE) {
		std::cerr << "glDeleteShader GL_INVALID_VALUE: _shader is not a value generated by OpenGL." << std::endl;
	} else {
		std::cerr << "Unknown glDeleteShader error." << std::endl;
	}
}

void checkGlDeleteBuffers(GLenum err) {
	if (err == GL_INVALID_VALUE) {
		std::cerr << "glDeleteBuffers GL_INVALID_VALUE: _n is negative." << std::endl;
	} else {
		std::cerr << "Unknown glDeleteBuffers error." << std::endl;
	}
}

void checkGlGenVertexArrays(GLenum err) {
	if (err == GL_INVALID_VALUE) {
		std::cerr << "glGenVertexArrays GL_INVALID_VALUE: _n is negative." << std::endl;
	} else {
		std::cerr << "Unknown glGenVertexArrays error." << std::endl;
	}
}

void checkGlDeleteVertexArrays(GLenum err) {
	if (err == GL_INVALID_VALUE) {
		std::cerr << "glDeleteVertexArrays GL_INVALID_VALUE: _n is negative." << std::endl;
	} else {
		std::cerr << "Unknown glDeleteVertexArrays error." << std::endl;
	}
}

void checkGlBindVertexArray(GLenum err) {
	if (err == GL_INVALID_OPERATION) {
		std::cerr << "glBindVertexArray GL_INVALID_OPERATION: _array is not zero or the name of a vertex array object ";
		std::cerr << "previously returned from a call to glGenVertexArrays." << std::endl;
	} else {
		std::cerr << "Unknown glBindVertexArray error." << std::endl;
	}
}

void checkGlUseProgram(GLenum err) {
	switch (err) {
		case GL_INVALID_VALUE:
			std::cerr << "glUseProgram GL_INVALID_VALUE: _program is neither 0 nor a value generated by OpenGL."
					  << std::endl;
			break;
		case GL_INVALID_OPERATION:
			std::cerr << "glUseProgram GL_INVALID_OPERATION: Either;";
			std::cerr << "\n\t1) _program is not a program object. Or,";
			std::cerr << "\n\t2) _program could not be made part of current state. Or,";
			std::cerr << "\n\t3) _transform feedback mode is active and not paused." << std::endl;
			break;

		default:
			std::cerr << "Unknown glUseProgram error." << std::endl;
	}
}

void checkGlDrawArrays(GLenum err) {
	switch (err) {
		case GL_INVALID_ENUM:
			std::cerr << "glDrawArrays GL_INVALID_ENUM: _mode is not an accepted value." << std::endl;
			break;
		case GL_INVALID_VALUE:
			std::cerr << "glDrawArrays GL_INVALID_VALUE: _count is negative." << std::endl;
			break;
		case GL_INVALID_OPERATION:
			std::cerr << "glDrawArrays GL_INVALID_OPERATION: Either;";
			std::cerr << "\n\t1) A non-zero buffer object name is bound to an enabled array and the buffer object's ";
			std::cerr << "data store is currently mapped. Or,";
			std::cerr << "\n\t2) Recording the vertices of a primitive to the buffer objects being used for transform ";
			std::cerr << "feedback purposes would result in either exceeding the limits of any buffer objectâ€™s size, ";
			std::cerr << "or in exceeding the end position offset + size - 1, as set by ";
			std::cerr << "glBindBufferRange." << std::endl;
			break;
		case GL_INVALID_FRAMEBUFFER_OPERATION:
			std::cerr << "GlDrawArrays GL_INVALID_FRAMEBUFFER_OPERATION: The currently bound framebuffer is not ";
			std::cerr << "framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not ";
			std::cerr << "GL_FRAMEBUFFER_COMPLETE)." << std::endl;
			break;

		default:
			std::cerr << "Unknown glDrawArrays error." << std::endl;
			break;
	}
}

void checkGlClear(GLenum err) {
	if (err == GL_INVALID_VALUE) {
		std::cerr << "GlClear GL_INVALID_VALUE: _mask was not GL_DEPTH_CLEAR_VALUE, GL_COLOR_CLEAR_VALUE, or ";
		std::cerr << "GL_STENCIL_CLEAR_VALUE." << std::endl;
	} else {
		std::cerr << "Unknown glClear error." << std::endl;
	}
}

void uinta::glCheckError(gl_error_check_type type) {
#ifdef UINTA_DEBUG
	GLenum err = glGetError();
	if (!err) return;

	switch (type) {
		case GL_BUFFER_DATA:
			checkGlBufferData(err);
			return;
		case GL_GEN_BUFFERS:
			checkGlGenBuffers(err);
			return;
		case GL_VERTEX_ATTRIB_POINTER:
			checkGlVertexAttribPointer(err);
			return;
		case GL_BUFFER_SUB_DATA:
			checkGlBufferSubData(err);
			break;
		case GL_BIND_BUFFER:
			checkGlBindBuffer(err);
			break;
		case GL_DISABLE_VERTEX_ATTRIB_ARRAY:
			checkGlDisableVertexAttribArray(err);
			break;
		case GL_ENABLE_VERTEX_ATTRIB_ARRAY:
			checkGlEnableVertexAttribArray(err);
			break;
		case GL_CREATE_SHADER:
			checkGlCreateShader(err);
			break;
		case GL_SHADER_SOURCE:
			checkGlShaderSource(err);
			break;
		case GL_COMPILE_SHADER:
			checkGlCompileShader(err);
			break;
		case GL_CREATE_PROGRAM:
			checkGlCreateProgram(err);
			break;
		case GL_ATTACH_SHADER:
			checkGlAttachShader(err);
			break;
		case GL_LINK_PROGRAM:
			checkGlLinkProgram(err);
			break;
		case GL_DELETE_SHADER:
			checkGlDeleteShader(err);
			break;
		case GL_DELETE_BUFFERS:
			checkGlDeleteBuffers(err);
			break;
		case GL_GEN_VERTEX_ARRAYS:
			checkGlGenVertexArrays(err);
			break;
		case GL_DELETE_VERTEX_ARRAYS:
			checkGlDeleteVertexArrays(err);
			break;
		case GL_BIND_VERTEX_ARRAY:
			checkGlBindVertexArray(err);
			break;
		case GL_USE_PROGRAM:
			checkGlUseProgram(err);
			break;
		case GL_DRAW_ARRAYS:
			checkGlDrawArrays(err);
			break;
		case GL_CLEAR:
			checkGlClear(err);
			break;
	}
#endif
}
